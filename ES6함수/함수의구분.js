//ES6이전까지 자바스크립트 함수는 별다른 구분 없이 다양한 목적으로 사용되었다.
//1. 일반적인 함수로서 호출할 수도 있고
//2. new 연산자와 함께 호출하여 인스턴스를 생성할 수 있는 생성자 함수로서 호출할 수도 있고
//3. 객채에 바인딩되어 메서드로서 호출할 수도 있다.

var foo = function () {
  return 1;
};
//일반적인 함수로서 호출
foo(); // 1

//생성자 함수로서 호출
new foo();

//메서드로서 호출
var obj = { foo: foo };
obj.foo();
//모두 callable이면서 constructor이다.

//객체에 바인딩된 함수도 일반 함수로서 호출할 수 있고 물론 생성자 함수로서 호출할 수도 있다.
var obj = {
  x: 10,
  f: function () {
    return this.x;
  },
};

//프로퍼티 f에 바인딩된 함수를 메서드로서 호출
console.log(obj.f()); // 10

//프로퍼티 f에 바인딩된 함수를 일반 함수로서 호출
var bar = obj.f;
console.log(bar()); //undefined

//프로퍼티 f에 바인딩된 함수를 생성자 함수로서 호출
console.log(new obj.f()); // f {}
//객체에 바인딩된 함수를 생성자 함수로 호출가능한 것은 문제가 있다.
//성능 면에서도 문제가 있다.
//객체에 바인딩된 함수가 constructor라는 것은 객체에 바인딩된 함수가 prototype 프로퍼티를 가지며, 프로토타입 객체도 생성한다는 것을 의미한다.
//함수에 전달되어 보조 함수의 역할을 수행하는 콜백함수도 마찬가지다.
//콜백함수도 constructor이기 때문에 불필요한 프로토타입 객체를 생성한다. 

//이러한 문제를 해결하기 위해, ES6에서는 함수를 사용 목적에 따라 세가지로 명확히 구분했다.
//1. 일반 함수, 2. 메서드, 3. 화살표 함수
//ES6의 메서드와 화살표 함수는 non-constructor이다.